------
SHORT-TERM:

Features:
    - Connections between 'islands:' when you build a bridge between two words to
      build a longer, more impressive word.
    - Critical optimizations
    - Move selection (after generation, likely start out with naive high score).
    - UI. Curses/Nitrogen? CURSES.
        - Set up main.erl to act as a server, respond to requests with a string. DONE
        - Set up client.rb to ping our new server, and receive response. DONE
        - Heavily define/specify what you will be sending to and fro, and create serializable
          datatypes on both ends.  
            - This mostly means prototyping a few transactions/use cases for the client, 
              and seeing what it 'needs.'  Also need to answer the question:  do you
              want to simulate a whole game, or just prod the AI?  Should the server
              store/retrieve games, or is that the client? DONE (see main:parse_message)

        - Test the serialization. DONE
        - Write game playing/flow logic.  Um, done?
        - Write Hello World in Ruby Curses, client.rb.  Um, done?
        - FINNISH HYMN!
            - Welcome Screen
                - Center Menu appropriately DONE
                - Draw title correctly DONE (copypasta)
                - Colors (DONE)
                - Get menu value
            -> Name input
                - Simple forms from example.  Get values, place in array.
                    - Title
                    - Bigger spaced box
                    - Enter rather than 'q'
                    - get the names in the forms!
            -> Action choose!       
                - Draw Board, Scores, * on who's turn.
        - TEST


Code Quality:

SERVER
    - Better, more rigorous testing.  Mostly in movesearches, and the most recent features (wildcards, 
      serialization, dumping previous computation to disk).  Use abstractions!
    - Optimize, optimize, optimize.  Especially with wildcards.
        Immediate, obvious optimizations:
            -> Don't check candidate tiles on the right/bottom of an occupied tile
               unless there isn't another way of reaching it, i.e. from above or from the right.
            -> Remove duplicate candidates and duplicate moves with a sort-and-filter (nlog(n)),
               rather than the current one-sweep naive traversal (n^2-ish).
            -> Make better use of spawn(), especially on all the maps and foldls.  Paralellize 
               candidates, for example.
    - Types with Dialyzer.
    - Refactor/restructure the src/ directory for a clear separation of modules:  game (for things 
      like boards, tiles, etc), server (for things like serialization and/or database handling), 
      and ai (for movesearches, finding the best move, etc.).

    - Use Thrift, instead of your crappy-ass homebrew serialization/deserializtion scheme.
      It's a hack where you gave much more than it deserved.

    - Generalize the board and board parser to take different default
      configurations, such as a Lexulous board, Words With Friends, or a custom
      board.  The hard-coding is more a result of the fact that I'm in a place with
      no internet and can't consult the Regex library, and also because this is
      slightly easier.  This will mostly involve changing the new_board to parse the
      board in lib/, and changing the BOARD_HEIGHT and BOARD_LENGTH constants to
      read from that file as well. Ideally, one could start a game parametrized by
      game type (words_with_friends) and dictionary (twl, international) etc.

    - I might be missing something. grep TODO and FIXME in the source to find something to do!


CLIENT
    - Allow save games.
    - Allow to check move validity on play_move
