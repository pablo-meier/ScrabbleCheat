// Taken from the autogenerated skeleton file.

#include "ScrabbleCheat.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/THttpServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>

#include <transport/TSocket.h>
#include <transport/TTransportUtils.h>
#include <protocol/TBinaryProtocol.h>

#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using std::cout;
using std::endl;

class ScrabbleCheatHandler : virtual public ScrabbleCheatIf {

private:

    static const int32_t kLocalScrabbleCheatPort = 8888;
	shared_ptr<ScrabbleCheatClient> m_client;

public:
	ScrabbleCheatHandler() {
		shared_ptr<TTransport> socket(new TSocket("127.0.0.1", kLocalScrabbleCheatPort));
		shared_ptr<TTransport> transport(new TBufferedTransport(socket));
		shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
		
		shared_ptr<ScrabbleCheatClient> client_initializer(new ScrabbleCheatClient(protocol));
		m_client = client_initializer;

		transport->open();
		cout << "Opened the transport, connected to local server on port " << kLocalScrabbleCheatPort << endl;
	}

	void new_game(Gamestate& _return, 
					const std::vector<std::string> & players, 
					const GameName::type game_name, 
					const Dictionary::type dict) {
		cout << "new_game" << endl;
		m_client->new_game(_return, players, game_name, dict);
		printf("new_game successful!");
	}

	void game_info(GameInfo& _return, const GameName::type game_name) {
		cout << "game_info" << endl;
		m_client->game_info(_return, game_name);
		cout << "game_info successful!" << endl;
	}

	void play_move(Gamestate& _return, const std::vector<Tile> & tiles, const Gamestate& gamestate) {
		cout << "play_move" << endl;
		m_client->play_move(_return, tiles, gamestate);
		cout << "play_move successful" << endl;
	}

	void pass_turn(Gamestate& _return, const Gamestate& gamestate) {
		printf("pass_turn\n");
		m_client->pass_turn(_return, gamestate);
		printf("pass_turn returned!\n");
	}

	void get_scrabblecheat_suggestions(std::vector<Move> & _return, 
										const std::string& rack, 
										const Board& board, 
										const GameName::type game_name, 
										const Dictionary::type dict) {
		cout << "get_scrabblecheat_suggestions" << endl;
		m_client->get_scrabblecheat_suggestions(_return, rack, board, game_name, dict);
		cout << "get_scrabblecheat_suggestions successful!" << endl;
	}

	void quit() {
		cout << "quit" << endl;
		m_client->quit();
		cout << "quit returned" << endl;
	}
};


// HTTP start code.
int main(int argc, char **argv) {
	int port = 9090;
	shared_ptr<ScrabbleCheatHandler> handler(new ScrabbleCheatHandler());
	shared_ptr<TProcessor> processor(new ScrabbleCheatProcessor(handler));

	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(new THttpServerTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
	
	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	cout << "Serving HTTP requests on port " << port << endl;
	server.serve();

	return 0;
}

