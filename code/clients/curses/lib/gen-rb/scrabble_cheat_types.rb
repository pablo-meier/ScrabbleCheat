#
# Autogenerated by Thrift Compiler (0.10.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module LetterType
  CHARACTER = 0
  WILDCARD = 1
  EMPTY = 2
  VALUE_MAP = {0 => "CHARACTER", 1 => "WILDCARD", 2 => "EMPTY"}
  VALID_VALUES = Set.new([CHARACTER, WILDCARD, EMPTY]).freeze
end

module Bonus
  TRIPLE_WORD_SCORE = 0
  DOUBLE_WORD_SCORE = 1
  TRIPLE_LETTER_SCORE = 2
  DOUBLE_LETTER_SCORE = 3
  NONE = 4
  VALUE_MAP = {0 => "TRIPLE_WORD_SCORE", 1 => "DOUBLE_WORD_SCORE", 2 => "TRIPLE_LETTER_SCORE", 3 => "DOUBLE_LETTER_SCORE", 4 => "NONE"}
  VALID_VALUES = Set.new([TRIPLE_WORD_SCORE, DOUBLE_WORD_SCORE, TRIPLE_LETTER_SCORE, DOUBLE_LETTER_SCORE, NONE]).freeze
end

module GameName
  SCRABBLE = 0
  WORDS_WITH_FRIENDS = 1
  LEXULOUS = 2
  VALUE_MAP = {0 => "SCRABBLE", 1 => "WORDS_WITH_FRIENDS", 2 => "LEXULOUS"}
  VALID_VALUES = Set.new([SCRABBLE, WORDS_WITH_FRIENDS, LEXULOUS]).freeze
end

module Dictionary
  TWL06 = 0
  SOWPODS = 1
  ZYNGA = 2
  VALUE_MAP = {0 => "TWL06", 1 => "SOWPODS", 2 => "ZYNGA"}
  VALID_VALUES = Set.new([TWL06, SOWPODS, ZYNGA]).freeze
end

# Basic datatype for a tile on the board.  'row' and 'col' are 1-indexed.
# If the tile is empty the string is empty and LetterType is EMPTY.
class Tile
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ROW = 1
  COL = 2
  TYPE = 3
  LETTER = 4
  BONUS = 5

  FIELDS = {
    ROW => {:type => ::Thrift::Types::BYTE, :name => 'row'},
    COL => {:type => ::Thrift::Types::BYTE, :name => 'col'},
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::LetterType},
    LETTER => {:type => ::Thrift::Types::STRING, :name => 'letter'},
    BONUS => {:type => ::Thrift::Types::I32, :name => 'bonus', :enum_class => ::Bonus}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @type.nil? || ::LetterType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
    unless @bonus.nil? || ::Bonus::VALID_VALUES.include?(@bonus)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field bonus!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class Move
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MOVE = 1
  SCORE = 2

  FIELDS = {
    MOVE => {:type => ::Thrift::Types::LIST, :name => 'move', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Tile}},
    SCORE => {:type => ::Thrift::Types::I16, :name => 'score'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class Turn
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MOVE = 1
  PLAYER = 2

  FIELDS = {
    MOVE => {:type => ::Thrift::Types::STRUCT, :name => 'move', :class => ::Move},
    PLAYER => {:type => ::Thrift::Types::STRING, :name => 'player'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class GameInfo
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NAME = 1
  RACK_SIZE = 2
  BINGO_BONUS = 3
  LETTER_DISTRIBUTION = 4
  SCORE_DISTRIBUTION = 5
  ALLOWED_DICTIONARIES = 6
  BOARD_TEMPLATE = 7

  FIELDS = {
    NAME => {:type => ::Thrift::Types::I32, :name => 'name', :enum_class => ::GameName},
    RACK_SIZE => {:type => ::Thrift::Types::BYTE, :name => 'rack_size'},
    BINGO_BONUS => {:type => ::Thrift::Types::MAP, :name => 'bingo_bonus', :key => {:type => ::Thrift::Types::BYTE}, :value => {:type => ::Thrift::Types::I32}},
    LETTER_DISTRIBUTION => {:type => ::Thrift::Types::MAP, :name => 'letter_distribution', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::BYTE}},
    SCORE_DISTRIBUTION => {:type => ::Thrift::Types::MAP, :name => 'score_distribution', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::BYTE}},
    ALLOWED_DICTIONARIES => {:type => ::Thrift::Types::LIST, :name => 'allowed_dictionaries', :element => {:type => ::Thrift::Types::I32, :enum_class => ::Dictionary}},
    BOARD_TEMPLATE => {:type => ::Thrift::Types::LIST, :name => 'board_template', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Tile}}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @name.nil? || ::GameName::VALID_VALUES.include?(@name)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field name!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# The primary data structure.  This allows the server to do any of its
# operations, and a client to display the game as needed to the client.
class Gamestate
  include ::Thrift::Struct, ::Thrift::Struct_Union
  BOARD = 1
  SCORES = 2
  PLAYER_TURN = 3
  TURN_ORDER = 4
  HISTORY = 5
  GAME_NAME = 6
  DICT = 7

  FIELDS = {
    BOARD => {:type => ::Thrift::Types::LIST, :name => 'board', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Tile}},
    SCORES => {:type => ::Thrift::Types::MAP, :name => 'scores', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I16}},
    PLAYER_TURN => {:type => ::Thrift::Types::STRING, :name => 'player_turn'},
    TURN_ORDER => {:type => ::Thrift::Types::LIST, :name => 'turn_order', :element => {:type => ::Thrift::Types::STRING}},
    HISTORY => {:type => ::Thrift::Types::LIST, :name => 'history', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Turn}},
    GAME_NAME => {:type => ::Thrift::Types::I32, :name => 'game_name', :enum_class => ::GameName},
    DICT => {:type => ::Thrift::Types::I32, :name => 'dict', :enum_class => ::Dictionary}
  }

  def struct_fields; FIELDS; end

  def validate
    unless @game_name.nil? || ::GameName::VALID_VALUES.include?(@game_name)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field game_name!')
    end
    unless @dict.nil? || ::Dictionary::VALID_VALUES.include?(@dict)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field dict!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# Called when you pass in bad arguments.
class BadArgsException < ::Thrift::Exception
  include ::Thrift::Struct, ::Thrift::Struct_Union
  def initialize(message=nil)
    super()
    self.reprimand = message
  end

  def message; reprimand end

  REPRIMAND = 1

  FIELDS = {
    REPRIMAND => {:type => ::Thrift::Types::STRING, :name => 'reprimand'}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

